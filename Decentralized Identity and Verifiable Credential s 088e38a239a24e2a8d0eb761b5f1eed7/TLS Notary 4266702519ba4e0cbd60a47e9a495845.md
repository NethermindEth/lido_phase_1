# TLS Notary

Abstract: TLSNotary is a browser add-on which allows you (the auditee) to prove to the auditor that a certain HTTPS page is present in a web browser, without compromising your internet connection, passwords or credentials. TLSNotary can be used e.g. to prove to the auditor that you made an online bank transfer.
TLSNotary does not do man-in-the-middle snooping, but relies on SSL/TLS cryptography. TLSNotary page captures are non-forgeable.
Added to deliverable?: No
Already read?: No
Assigned readers: Ahmet Ramazan Agirtas, Basireddy Swaroopa Reddy
Classification: Data to Web3
Labels: Legacy compatible, Possible tool in larger solution, Web2 to Web3 data transfer
Link to the paper: https://tlsnotary.github.io/docs-mdbook/
MZ checked the note: No
Presentation date: November 25, 2022
Score Phase 1: Relevant
Work Group: Hybrid

Assuring the authenticity of the data that is pulled from web2 servers is an important task for the next phases of the Lido project. For the first phase, we check the existing solutions such as [DECO](DECO%203cafe2e2a6da4e5aa047f00a3c85cccd.md), TLSNotary, and TLS-N. We examined the [DECO](DECO%203cafe2e2a6da4e5aa047f00a3c85cccd.md) protocol in a separate note.

TLSNotary is a protocol that allows a user (Requester) to prove to a verifier (Notary) that he interacted with a certain Server and that the transcript between them was not altered. It is a modified version of the standard TLS protocol. 

The main idea of the TLSNotary protocol is to split the session keys of the client into two parts, and the Requester and the Notary participate in a two-party computation (2PC) with their key shares to jointly communicate with the server. Neither the Requester nor the Notary knows the session keys. They only have shares of them. 

The first version of TLSNotary which was released in 2014 [[1]](https://github.com/tlsnotary/tlsnotary/blob/master/src/documentation/TLSNotary.pdf) only supports TLS 1.1 and older versions. However, we see that the TLSNotary protocol is updated so that it supports TLS 1.2 and newer versions.

# Preliminary

There are three parties in the TLSNotary protocol, i.e. Requester, Notary, and Server. 

## **The Requester**

It is the party that interacts with the Server through a TLS session. The Requester can encrypt a request with a session key, and send it to the Server. Upon receiving the encrypted response from the Server, the Requester gets help from the Notary to decrypt it. Only the Requester can see the decrypted data.

## **The Notary**

It is the party that the Requester aims to convince. He holds partial session keys, and he participates in two-party computation (2PC) with the Requester to achieve the TLS session. He doesn’t see the decrypted response of the Server, but he has a commitment to the decrypted data. 

## **The Server**

It is a standard party in a TLS session. It can be any server supporting TLS protocol. The protocol is transparent to the Server, i.e. the Server cannot distinguish whether it interacts with a client for a standard TLS or a TLSNotary session. 

## The differences between TLS versions

According to [RFC5246](https://www.rfc-editor.org/rfc/rfc5246#section-1.2), the major differences between TLS 1.1 and TLS 1.2+  are 

- $MD5/SHA\text{-}1$-based PRF is replaced with $P\_SHA256$.
- $MD5/SHA\text{-}1$ based signed element is replaced with a single $SHA256$.
- Authenticated encryption support is added.
- $TLS\_RSA\_WITH\_AES\_128\_CBC\_SHA$ became mandatory to implement the cipher suite.
- Added $HMAC\text{-}SHA256$ cipher suites.
- Removed IDEA and DES cipher suites.

# TLSNotary

First, we see the general structure in the below figure, then we’ll describe each building block in the next sections. 

![Source: [https://docs.tlsnotary.org/protocol/notarization/index.html](https://docs.tlsnotary.org/protocol/notarization/index.html)

**Figure.1.** This is a simple modification of the main interaction between the server and the client in a TLS 1.2 session. The operations on the client side are performed by the Requester and the Notary by secure 2PCs. ](TLS%20Notary%204266702519ba4e0cbd60a47e9a495845/Untitled.png)

Source: [https://docs.tlsnotary.org/protocol/notarization/index.html](https://docs.tlsnotary.org/protocol/notarization/index.html)

**Figure.1.** This is a simple modification of the main interaction between the server and the client in a TLS 1.2 session. The operations on the client side are performed by the Requester and the Notary by secure 2PCs. 

## Transcript

The Transcript is a collection of data that includes metadata, handshake data, and the commitments to the requests and the responses. If the Notary is not the verifier, the Notary is required to sign the Transcript to present it to a verifier. 

![Source: [https://docs.tlsnotary.org/protocol/notarization/index.html](https://docs.tlsnotary.org/protocol/notarization/index.html)

**Figure.2.** This figure depicts the structure of a Transcript which is the main output of the TLSNotary protocol. In addition to outputting the Transcript, the Notary is required to sign on the Transcript if he is not the verifier. Then the signed Transcript can be presented to the verifier to show that the data is authentic and it is notarized by the Notary.](TLS%20Notary%204266702519ba4e0cbd60a47e9a495845/Untitled%201.png)

Source: [https://docs.tlsnotary.org/protocol/notarization/index.html](https://docs.tlsnotary.org/protocol/notarization/index.html)

**Figure.2.** This figure depicts the structure of a Transcript which is the main output of the TLSNotary protocol. In addition to outputting the Transcript, the Notary is required to sign on the Transcript if he is not the verifier. Then the signed Transcript can be presented to the verifier to show that the data is authentic and it is notarized by the Notary.

## Key Exchange

In all versions of the TLS protocol, the session keys are obtained by a key exchange protocol. To that end, the Server, the Requester, and the Notary participate in the below [Elliptic Curve Diffie-Hellman (ECDH)](https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman) key exchange protocol. 

![Source: [https://docs.tlsnotary.org/protocol/notarization/key_exchange.html](https://docs.tlsnotary.org/protocol/notarization/key_exchange.html)

**Figure.3.** This is a modified version of a standard Elliptic Curve Diffie-Hellman (ECDH) key exchange protocol. The operations on the client side are jointly performed by the Requester and the Notary by a secure 2PC.](TLS%20Notary%204266702519ba4e0cbd60a47e9a495845/Untitled%202.png)

Source: [https://docs.tlsnotary.org/protocol/notarization/key_exchange.html](https://docs.tlsnotary.org/protocol/notarization/key_exchange.html)

**Figure.3.** This is a modified version of a standard Elliptic Curve Diffie-Hellman (ECDH) key exchange protocol. The operations on the client side are jointly performed by the Requester and the Notary by a secure 2PC.

The 3-party [ECDH](https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman) protocol between the Server, the Requester, and the Notary results in Pre-master Secret (PMS) shares for the Requester and the Notary as follows:

1. The Server sends its public key $Q_s$ to the Requester, and the Requester sends it to the Notary.
2. The Requester picks a random private key $d_r$, and computes his public key $Q_r = d_rG$
3. The Notary also picks a random private key $d_n$, and computes his public key $Q_n = d_nG$
4. The Notary sends his public key $Q_n$ to the Requester.
5. The Requester computes the client public key $Q_c = Q_r + Q_n$, and sends it to the Server.
6. The Requester computes the elliptic curve point $(x_r, y_r)=d_rQ_s$
7. The Notary computes the elliptic curve point $(x_n, y_n)=d_nQ_s$
8. Addition of the elliptic curve points $(x_r, y_r)$ and $(x_n, y_n)$ results in $(x_c, y_c)$, where $x_c$ is the PMS (note that $y_c$ is not used in TLS) 

Now the goal is to compute $x_c = \Big(\frac{y_n - y_r}{x_n - x_r}\Big)^2 - x_r - x_n$ by **a secure two-party computation.**

To do that, an M2A (multiplicative-to-additive) and A2M (additive-to-multiplicative) protocols from [[7]](https://www.cs.umd.edu/~fenghao/paper/modexp.pdf) are used.

- Apply A2M to $y_n + (-y_r)$ and obtain $A_nA_p$.
- Apply A2M to $x_n + (-x_r)$ and obtain $B_nB_p$.
- Now we can rewrite $x_r$ as
    - $x_c = (\frac{A_n}{B_n})^2(\frac{A_r}{B_r})^2 - x_r - x_n$,
    - $(\frac{A_n}{B_n})^2$ can be computed by the Notary, he obtains $C_n$,
    - $(\frac{A_r}{B_r})^2$ can be computed by the Requester, he obtains $C_r$.
- Now we have $x_c = C_nC_r - x_r - x_n$.
- Now apply M2A to $C_nC_r$ to obtain $D_n + D_r$.
- We have $x_c = (D_n-x_n) + (D_r-x_r)$
- The PMS share of the Notary is $(D_n - x_n)$
- The PMS share of the Requester is $(D_r - x_r)$

## Key derivation

The PMS, which is obtained by the above key exchange protocol, must be used as input of a pseudo-random function (PRF) to

- compute the symmetric TLS keys and
- compute the `verify_data` for the `Client_Finished` and the `Server_Finished` messages.

All these computations are performed in a 2PC fashion. We skip the details on 2PC. For further information please see [here](https://docs.tlsnotary.org/protocol/notarization/prf.html#overview).

## Commitment

At the end of the TLSNotary protocol, the Requester has some encrypted data (AES ciphertext). Although this may also be seen as a commitment to a plaintext, this kind of commitment is not flexible enough, especially for cases when a Requester wants to partially reveal the plaintext. 

So, how can a Requester transform the ciphertext into a commitment? 

He can prove the decryption in zero-knowledge, but this is not the computationally cheapest way to do that. 

For the same purpose, two approaches are proposed in the documents of TLSNotary:

1. Decrypting the ciphertext with [Garbled Circuits](https://en.wikipedia.org/wiki/Garbled_circuit) and producing a hash commitment to the wire labels. (useful for committing to the data to be made public)
2. Producing a [Poseidon hash](https://eprint.iacr.org/2019/458.pdf) over the private data (useful for proving the statements about some private data in zero-knowledge)

We skip the details. For further information please see [here](https://docs.tlsnotary.org/protocol/notarization/public_data_commitment.html).

# Implementation

- In 2015, the first version of PageSigner, which is a Chrome extension for the TLSNotary client side, was released.
- In 2020, PageSigner v.2 (supporting TLS 1.2) was released.
- On November 21, 2021, Pagesigner v.3 was released. It is announced that it supports TLS 1.2+.

# References

1. [https://github.com/tlsnotary/tlsnotary/blob/master/src/documentation/TLSNotary.pdf](https://github.com/tlsnotary/tlsnotary/blob/master/src/documentation/TLSNotary.pdf)
2. [https://github.com/tlsnotary](https://github.com/tlsnotary)
3. https://github.com/tlsnotary/tlsnotary
4. [https://tlsnotary.github.io/docs-mdbook/](https://tlsnotary.github.io/docs-mdbook/)
5. [https://tlsnotary.org/TLSNotary.pdf](https://tlsnotary.org/TLSNotary.pdf)
6. [https://en.wikipedia.org/wiki/Elliptic-curve_Diffie–Hellman](https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman)
7. [https://www.cs.umd.edu/~fenghao/paper/modexp.pdf](https://www.cs.umd.edu/~fenghao/paper/modexp.pdf)
8. [https://en.wikipedia.org/wiki/Garbled_circuit](https://en.wikipedia.org/wiki/Garbled_circuit)
9. [https://eprint.iacr.org/2019/458.pdf](https://eprint.iacr.org/2019/458.pdf)
10. [https://old.tlsnotary.org/wp/?p=8](https://old.tlsnotary.org/wp/?p=8)
11. [https://www.rfc-editor.org/rfc/rfc5246#section-1.2](https://www.rfc-editor.org/rfc/rfc5246#section-1.2)