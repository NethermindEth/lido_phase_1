# DECO

Abstract: Thanks to the widespread deployment of TLS, users can access private data over channels with end-to-end confidentiality and integrity. What they cannot do, however, is prove to third parties the provenance of such data, i.e., that it genuinely came from a particular website. Existing approaches either introduce undesirable trust assumptions or require server-side modifications. As a result, the value of users' private data is locked up in its point of origin. Users cannot export their data with preserved integrity to other applications without help and permission from the current data holder. We propose DECO (short for decentralized oracle to address the above problems. DECO allows users to prove that a piece of data accessed via TLS came from a particular website and optionally prove statements about such data in zero-knowledge, keeping the data itself secret. DECO is the first such system that works without trusted hardware or server-side modifications. DECO can liberate data from centralized web-service silos, making it accessible to a rich spectrum of applications. To demonstrate the power of DECO, we implement three applications that are hard to achieve without it: a private financial instrument using smart contracts, converting legacy credentials to anonymous credentials, and verifiable claims against price discrimination.
Actions needed and questions: Describe in “One getting data to Web3” part
Added to deliverable?: Yes
Already read?: Yes
Assigned readers: Ignacio, Ahmet Ramazan Agirtas
Classification: DI, Data to Web3
Date of publication: 2019
Labels: Implementations, Legacy compatible, Management of credentials, Possible tool in larger solution, Worthwile Sybil resistance insights
Link to the paper: https://www.deco.works/
MZ checked the note: No
Presentation date: November 1, 2022
Reviewers: Aikaterini-Panagiota Stouka
Score Phase 1: Very relevant
Work Group: Hybrid

# DECO

### **Roles**

- **Server($\mathcal{S}$)**: Data source which supports TLS protocol.
- **Prover($\mathcal{P}$)**: Off-chain repeater that requests data from the server, generates a proof of validity, then sends it to the verifier.
- **Verifier($\mathcal{V}$)**: On-chain Oracle node, receives the data and proof from the prover and verifies its correctness.

### Notation

- $sid$: the session ID, unique per session.
- $r$: randomly generated bit string.
- $Q$: query information.
- $R$: respond information.
- $\mathcal{\sigma}$: signature.
- $τ$: MAC tag.

### Transport Layer Security (TLS) protocol

1. The client sends “client hello” to the server, along with TLS type, and cipher suits with a random $r^c$ generated by the client.
2. The server receives the data, and sends “server hello” to the client, along with Certificate, cipher suits with a random $r^s$ generated by the server, and the server’s public key $K^s$.
3. The client receives the data, and generates a random premaster secret $r^{ps}$, encrypts it with $K^s$, and sends it to the server. 
4. The server using the secret key decrypts the message and reveals $r^{ps}$. For both server and client, the session key is $r^c+r^s+r^{ps}$.
5. **The server uses the session key with symmetric encryption** to encrypt the handshake completes the message and sends it to the client. TLS handshake complete.

![ [https://www.ssl2buy.com/wiki/wp-content/uploads/2021/02/ssl-tls-handshake.png](https://www.ssl2buy.com/wiki/wp-content/uploads/2021/02/ssl-tls-handshake.png)](DECO%203cafe2e2a6da4e5aa047f00a3c85cccd/Untitled.png)

 [https://www.ssl2buy.com/wiki/wp-content/uploads/2021/02/ssl-tls-handshake.png](https://www.ssl2buy.com/wiki/wp-content/uploads/2021/02/ssl-tls-handshake.png)

### A strawman protocol

- Prover $\mathcal{P}$ constructs a TLS channel with server $\mathcal{S}$ with session keys $(k^{MAC},k^{Enc})$, and queries $\mathcal{S}$ with queries $\mathcal{\hat{Q}}=(\hat{Q_1},\hat{Q_2}.....\hat{Q_n})$.
- $\mathcal{S}$ responds $\mathcal{\hat{R}}=(\hat{R_1},\hat{R_2}.....\hat{R_n})$ to $\mathcal{P}$, then $\mathcal{P}$ proves the following statements:
    - Each $\hat{R}_i$ decrypts to $R_i||σ_i$, where $R_i$  is plaintext and $σ_i$ is MAC tag.
    - Each $R_i$  and $σ_i$ verifies against $k^{MAC}$.
    - The desired statement evaluates to $b$ on the response, i.e., $b = Stmt(R)$

- $\mathcal{P}$ **knows $(k^{MAC},k^{Enc})$, therefore $\mathcal{P}$ can forge any statement. The goal of DECO is to separate $K^{MAC}$ into $K^{MAC}=K^{MAC}_{\mathcal{P}}+K^{MAC}_{\mathcal{V}}$, so that $\mathcal{P}$ cannot forge a fake proof.**

### DECO Procedure

![Untitled](DECO%203cafe2e2a6da4e5aa047f00a3c85cccd/Untitled%201.png)

- **Trigger**:
    - Verifier ($\mathcal{V}$) is asked for off-chain data,
    - $\mathcal{V}$ generates **a session ID** ($sid$), **a query template** ($Query$), and **a statement** ($Stmt$) to be proven.
    - $\mathcal{V}$ sends $(sid, Query,Stmt)$ to $\mathcal{P}$.
- **Three-party handshake**: The goal of the three-party handshake is to run a TLS handshake protocol, which for the server ($\mathcal{S}$) side is just following the standard TLS protocol, but the prover ($\mathcal{P}$) and verifier ($\mathcal{V}$) use a separated key which can be combined to communicate with the server. (All additions and multiplications are **EC operations**)
    1. $\mathcal{P}$ sends “client hello” to  $\mathcal{S}$, along with TLS type, cipher suits with **a random** $r_c$ generated by $\mathcal{P}$.
    2. $\mathcal{S}$ receives the data, sends “server hello” to $\mathcal{P}$, along with **certificate** $cert$, cipher suits with **a random** $r_s$ generate by the server, and **server’s public key** $Y_S$ and **a signature** $\mathcal{\sigma}$ over $(r_c, r_s, Y_S)$.
    3. $\mathcal{P}$ verifies that $cert$ is valid and $\mathcal{\sigma}$ is valid over $(r_c, r_s, Y_S)$, then sends $(r_c, r_s, Y_S,\mathcal{\sigma},cert)$ to $\mathcal{V}$. Then $\mathcal{V}$ checks the same thing also. 
    4. $\mathcal P$ and $\mathcal V$ jointly generate a private key:
        1. $\mathcal{V}$ generates a **secret** $s_v$, calculates the **verifier premaster key** $Y_V=s_v*G$, and sends $Y_V$ to $\mathcal{P}$.
        2. $\mathcal{P}$ generates a **secret** $s_p$, calculates the **prover premaster key** $Y_P=s_p*G$, runs the **key exchange procedure,** and sends $Y_P+Y_V$ to $\mathcal{S}$ after encrypting with $Y_S$.
        3. $\mathcal P$ an $\mathcal V$ run $ECtF$ to compute a **sharing of x-coordinate** of $Y_P+Y_V$, denoted as $z_P$ and $z_V$.
            
            ![Untitled](DECO%203cafe2e2a6da4e5aa047f00a3c85cccd/Untitled%202.png)
            
        4. $\mathcal P$ and $\mathcal V$ send $z_P$  and $z_V$ to $\mathcal F_{2PC}^{hs}$ to compute $(k^{Enc},r_k,r_m)$ and $(r_k⊕k^{MAC},r_m⊕m)$, send to $\mathcal P$and $\mathcal V$ respectively, which is $(k^{Enc},k^{MAC}_{\mathcal{P}},m_{\mathcal{P}})$ and $(k^{MAC}_{\mathcal{V}},m_{\mathcal{V}})$.
            
            ![Untitled](DECO%203cafe2e2a6da4e5aa047f00a3c85cccd/Untitled%203.png)
            
        5. $\mathcal{P}$ computes a hash $h$ of the handshake massages, and runs a 2PC-PRF with $\mathcal{V}$ to compute $s_p=PRF(m_{\mathcal{P}}⊕m_{\mathcal{V}},$ “*client finished”$,h)$*, sends to $\mathcal{S}$.
        6. $\mathcal{S}$ computes $s_s=PRF(m_{\mathcal{P}}⊕m_{\mathcal{V}},$ “*server finished”$,h)$*, sends it to $\mathcal{P}$, then $\mathcal{P}$ and $\mathcal{V}$ recompute and check if $s_s=PRF(m_{\mathcal{P}}⊕m_{\mathcal{V}},$ “*server finished”$,h)$*, and abort if not. Three-party handshake complete. 
        
    
    **Note that at the end of the three-party handshake,** 
    
    - $**P$ obtains $k^{MAC}_{P}$ and  $k^{Enc}$,**
    - $**V$ obtains $k^{MAC}_{V}$.**
    
- **Query execution**:
    1. $\mathcal{P}$ constructs the query using the template $Q=Query(θ_s)$, $θ_s$ is some secret parameter stored in $\mathcal{P}$, e.g. API key, password, etc. 
    2. $\mathcal{P}$ invokes **2PC-HMAC** with $\mathcal{V}$ to compute a tag $\mathcal{τ}$ which signs the query message $Q$, sends $(sid, \hat{Q}=Enc(k^{Enc},Q||τ)$ to $\mathcal{S}$. (The goal of this step is to **ensure that the content of the query is not been manipulated** by $\mathcal P$).
        
        The goal of 2PC-HMAC is to compute $HMAC_H(k^{MAC},m)$, which is the following equation, where $opad$ is $01011100$ repeated and $ipad$ is $00110110$ repeated.
        
        $$
        HMAC_H(k^{MAC},m)=H((k^{MAC}⊕opad)||H((k^{MAC}⊕ipad)||m))
        $$
        
        1. $\mathcal{P}$ and $\mathcal{V}$ input $k^{MAC}_{\mathcal{P}}$ and $k^{MAC}_{\mathcal{V}}$ to run a 2PC to compute $s_0=f(IV,k^{MAC}⊕ipad)$, and reveal $s_0$ to $\mathcal{P}$, where $f$ denotes a compression hash function of SHA256 and $IV$ is an initialization vector.
        2. $\mathcal{P}$ computes the inner hash $h_i=f(s_0,Q)$, which represents $H((k^{MAC}⊕ipad)||Q)$ in the above equation. 
        3. $\mathcal{P}$ inputs $k^{MAC}_{\mathcal{P}}$, $h_i$ and $\mathcal{V}$ inputs $k^{MAC}_{\mathcal{V}}$ to run a 2PC to compute $H((k^{MAC}⊕opad)||h_i)$, which is $τ$.
- **Commit and verify**:
    1. $\mathcal{P}$ sends $(sid, \hat{Q}=Enc(k^{Enc},Q||τ)$ to $\mathcal{S}$.
    2. $\mathcal{S}$ responds to $\mathcal{P}$ with $(sid, \hat R)$, 
        1. $\mathcal{P}$ sends $(sid, \hat R,k^{MAC}_{\mathcal P})$  to $\mathcal{V}$, 
        2. then $\mathcal V$ sends back $(sid,k^{MAC}_{\mathcal V})$.
    3. $\mathcal{P}$ computes $k^{MAC}=k^{MAC}_{\mathcal P}+k^{MAC}_{\mathcal V}$, decrypts $R||τ=Dec(k^{Enc},\hat R)$, and verifies $τ$ with $k^{MAC}$. 
- **Proof generation**:
    1. Define $b=Stmt(R)$ which is a statement about the respond $R$ (e.g: “Alice has more than $3000 in the bank balance”), $x=(k^{Enc},θ_s,Q,R)$, $w=(\hat Q, \hat R, k^{MAC},b)$, $\mathcal{P}$ sends $(sid,"prove",x,w)$ to **ZKP function** $\mathcal{F}_{ZK}$.
    2. $\mathcal{F}_{ZK}$ constructs a **relation** $π(x,w)∈\left\{ {0,1}\right\}$, which is $1$ if and only if:
        1. $\hat Q$ and $\hat R$ are the ciphertexts of $Q$ and $R||τ$ under $k^{Enc}$ and $k^{MAC}$.
        2. $Query(θ_s)=Q$
        3. $Stmt(R) = b$
    3. $\mathcal{F}_{ZK}$ sends $(sid,"proof",π,(\hat Q, \hat R, \hat k^{MAC},b))$ to $\mathcal V$.
    4. $\mathcal V$ checks if $\hat k^{MAC}=k^{MAC}_\mathcal V+k^{MAC}_\mathcal P$, and verifies the proof $\pi$.