# Polygon Id

Classification: DI, VC
Labels: Management of credentials, Permissionless, Possible tool in larger solution, Smart Contracts instead of oracles
Link to the paper: https://0xpolygonid.github.io/tutorials/
Score: no idea
Score Phase 1: Very relevant

Polygon Id aims to build a service that allows **Issuers** to issue claims about **Users** (including themselves) in a way that **Users** can prove properties (in zero-knowledge) about these claims to.

**Disclaimer**: Polygon Id aims to be a framework for projects that need to deal with Id functionalities. It does not aim to be a fully functioning Id ecosystem as other projects we have reviewed (Sismo, Interep, Keybase, etc)

## Concepts and Methods

### Claim

A **claim** is a private tuple of the form

$$
\text{Claim = (User Id, Schema, Data, Metadata)}
$$

**Example:** A university could issue a claim of the form $\text{(Student Id, Diploma, [Title of degree, transcript, etc])}$

Claims are supposed to remain private: only the issuer and the User receiving the claim should know its contents. Additionally, the issuer looses all control and trackability of the claim once issued.

### Identity

Polygon Id is somewhat more abstract than other similar projects presented in this survey.

It uses the concept of **Identity**. These are either Issuers or Holders. 

The two types of parties are captured by the same abstract functionality.

An Identity can make claims about itself or other Identities. 

Importantly, an Identity has at least one claim involving its private key:

$$
\text{Key Claim = (Identity Id, Private key schema, actual private key)}
$$

Identities have **Identity states**. These are the hash of a forest of Merkle trees:

![Untitled.png](Polygon%20Id%2046505e46892d4010801f49b1114a8450/Untitled.png)

The claims MT is the Merkle Tree of all the identity’s claims. This is private. 

The Revocation MT allows for revocating claims.

The Roots MT allows proving statements about claims that were valid at some point in the past. 

The latter two MT’s are public. Polygon Id proposes storing them in an HTTPS address or an IPFS link.

(More details follow)

Id states are posted on the blockchain by the Identity, and become associated to a timestamp. 

Every time there is a change in the Id State, the Identity updates its state on the blockchain. (Polygon Id discusses some methods to allow for batching the post of many Id State updates at once. The approach uses relayers.)

A smart contract in the blockchain verifies that Id State transitions (i.e., the update of one Id state into a new one) are performed according to some rules. The verification is a Groth16 verification. 

Examples of rules:

- The update is made by the Identity itself, not by an alien party. 
To prove this in zero-knowledge, the Identity would provide the Merkle proof that it knows the private key in its “Key Claim”
- The update is made by some delegate party.
- No Revocation Nonce in the Revocation Merkle Tree has been removed. (Polygon Id does not allow to “unrevoke” a revoked claim). Similarly, no Claim has been downgraded (see later).

Next we present the most basic Issuing, Proving, and Verifying methods from Polygon Id. Later we will discuss some extensions.

### Issuing claims (credentials)

**Id1 (Issuer)** can send a **Claim $C$** to **Id2 (Holder)**, together with the **Merkle Proof that $C$** is in the Claims Merkle Tree of **Id1**. It additionally signs **Claim C** and sends a proof of such signature.

To enable more advanced functionality, **Id1** may send some extra data to **Id2**.

(Note, in principle, it is not necessary to send a proof of such signature since **Id1** is supposed to update its Id State on the blockchain, and to do so it has to prove that it knows its private key, so the **Id1** is implicitly signing the claim at that point. However, it could happen that **Id1** takes a long time to update the state —in this case **Id2** would still be able to prove statements about its **Claim** in a trustworthy manner)

### Proof and Verification

Now **Id2 (Holder)** can use a zk-SNARK to prove in zero-knowledge that: 

- It owns **Claim $C$.** To do so, it proves in zero-knowledge that it knows a Merkle Proof for $C$, and also that ****$C$ was signed by the issuer.
- The values in **Claim $C$** satisfy some properties (e.g. the Student passed at least one course with a high degree)
- The key in the Key Claim in **Id2** is associated with the Identity Id that **Claim C** refers to (i.e. **Id2** authenticates itself)

without revealing any sensitive information.

The Verifier checks the validity of the such proof.

### Extra features

The Revocation Tree and the Roots Tree provide some convenient functionality:

**Revocation of claims**

Each claim contains a metadata piece of info, a “Revocation Nonce”. 

When a Holder creates a proof of a statement about a Claim, it also proves that the Revocation Nonce is not in the Revocation Merkle Tree (Recall that the Revocation Tree is public), and sends such proof to the Verifier.

A question: how can the latter be done efficiently? Some kind of “negative” lookup? 

**Temporal proofs**

The leaves in the Roots Merkle Tree consist of all the roots of the Claims, Revocation, and Root Merkle Trees of the Identity. 

This allows Holders to prove statements about Claims which were true in some past timestamp. 

For example, Bob can prove that he got his diploma before a certain timestamp.

The procedure is as before, but now one uses the appropriate Merkle roots stored in the Roots Merkle Trees, which is a public tree, instead of the most current Id state of the Issuer Id1.  

(For the Merkle proof, Id2 uses a subpath of the whole Merkle Proof it owns. This subpath ends in the root of the Claims MT at the appropriate time).

**Upgradable claims.** Claims can be modified. To enable this, claims have a version number in their metadata and a reference to its previous version. To modify a claim, a new claim is added to the Claims MT, with appropriate metadata. All previous versions of the Claim have to be revoked; hence, the Revocation Tree is updated accordingly.

## High-level discussion

### **The good**

- Polygon Id is permissionless and decentralized. In particular, it does not rely on oracles
- Verification can be made on-chain or off-chain: the Verifier can be a smart contract.
- Claims are revocable, upgradable, non-trackable, can be claims about past properties, and can be made to expire.

 

### **The tricky**

> Polygon Id needs no trust except in the legitimacy of the Issuing Identities, and the way they make sure that their Claims adjust to reality.
> 

For example, I can create an Identity to represent “University A” and start issuing diplomas to random Ethereum addresses (in this case, the Holder’s Id would be their Ethereum address). 

Note, however, that the credibility of “University A” would be damaged.

Notice that once we trust an Issuing identity with the above, we don’t need to trust it further. This is because Identities can only update their state according to some rules (state updates are made on-chain and verified by a Smart Contract).

Hence, besides the point raised above, Polygon Id exhibits very nice properties in the context of Lido.

Note that Polygon Id is not aiming to solve the point above, rather, they expect either:

- a third party to build on top of Polygon Id, addressing such types of issues
- trusted Issuers to start using Polygon Id. E.g. a government could create its Identity on Polygon Id, and we would all know it is legit since the government would be signing with its keys (assuming we trust that the alleged public key of the government indeed corresponds to a pk controlled by the government)

### **The bad**

It is relatively cheap for an Identity to share claims with another Identity, as long as it is willing to reveal its private key.

To mitigate this, one must ensure that the Identity’s private keys are linked to some valuable account or secret.

---

# Isaac’s write-up

[Isaac’s write-up](Polygon%20Id%2046505e46892d4010801f49b1114a8450/Isaac%E2%80%99s%20write-up%20b77f2f5a587043fcaf03d73f7b68575e.md)