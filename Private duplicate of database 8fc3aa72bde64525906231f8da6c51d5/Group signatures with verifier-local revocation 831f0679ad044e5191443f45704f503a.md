# Group signatures with verifier-local revocation

Abstract: Group signatures have recently become important for enabling privacy-preserving attestation in projects such as Microsoft's ngscb effort (formerly Palladium). Revocation is critical to the security of such systems. We construct a short group signature scheme that supports Verifier-Local Revocation (VLR). In this model, revocation messages are only sent to signature verifiers (as opposed to both signers and verifiers). Consequently there is no need to contact individual signers when some user is revoked. This model is appealing for systems providing attestation capabilities. Our signatures are as short as standard RSA signatures with comparable security. Security of our group signature (in the random oracle model) is based on the Strong Diffie-Hellman assumption and the Decision Linear assumption in bilinear groups. We give a precise model for VLR group signatures and discuss its implications.
Classification: Signature scheme
Labels: Anonymity revocation, Signature scheme
Link to the paper: https://dl.acm.org/doi/abs/10.1145/1030083.1030106
Score: no idea
Score Phase 1: Not relevant
Year: 2004

Cited in the paper from [Zero-knowledge credentials with deferred revocation checks](Zero-knowledge%20credentials%20with%20deferred%20revocatio%20e3684d2933e7499a8757a1c8c77e0e9b.md)

# **TL;DR**

**This paper proposes a group signature scheme which enables a member of a group to sign a message anonymously. It also provides a revocation property.** 

**Since this paper is out of the scope of our SoK, I labeled this paper as not relevant.**

# Introduction

Assume a group of users $G$. In a group signature scheme each user has a secret key that enables the user sign a message. Any verifier can verify that the signature is generated by someone in this group, but he cannot distinguish which member signed it. Only a third party (usually called group manager) can identify the signer’s identity.

Group signatures was firstly introduced by Chaum and van Heyst in 1991. And some other works was published in the following years, with or without revocation property. 

In general, one can consider three basic communication models for revoking a user, without affecting other users in the group $G$. These are 

1. revoking user $i$ by issuing a new signature verification key and giving other signers a fresh signing key. **This requires an individual secret message to each signer and a public broadcast message to all verifiers.**
2. Another method is sending a single short public **broadcast message to all signers and verifiers.** 
3. In the third one, the revocation **messages are only sent to signature verifiers.**

The group signatures having the third revocation model is called as **``Verifier-Local Revocation (VLR)" group signatures.** This paper proposes a group signature scheme which provides VLR property. 

The proposed scheme is based on Strong Diffie-Hellman (SDH) assumption in groups with a bilinear map.

### Notation

Throughout this note, vector of elements are denoted by boldface such as $\textbf{vec}$. And $\textbf{vec}[i]$ denotes the $i$-th element of the vector $\textbf{vec}$.

## Verifier-Local Revocation (VLR)

A VLR group signature scheme is composed of three algorithms, i.e. $\text KeyGen, Sign$ and $\text Verify$. 

- $\text KeyGen(n)\to (gpk,\textbf{gsk},\textbf{grt})$: It takes $n = |G|$ as input and outputs group public key $gpk$,  vector of group user keys $\textbf{gsk} = (\textbf{gsk}[1], \dots, \textbf{gsk}[n])$ and vector of users’ revocation token $\textbf{grt} = (\textbf{grt}[1], \dots, \textbf{grt}[n])$.
- $\text Sign(gpk, \textbf{gsk}[i], M)\to \sigma$: It takes group public key $gpk$, a secret key $\textbf{gsk}[i]$ and a message $M \in \{0,1\}^*$, and outputs a signature $\sigma$.
- $\text Verify(gpk, RL, \sigma, M) \to 0/1$: It takes the group public key $gpk$, a set of revocation tokens $RL$ (a subset of the entries of $\textbf{grt}$), and a purported signature $\sigma$ on a message $M$ as inputs and outputs accept or reject. If it is rejected it means two things, i.e. either the signature is invalid, or the signer is revoked.

### Implicit Tracing Algorithm

Given a valid message-signature pair $(M, \sigma)$, a party possessing all the revocation tokens $\textbf{grt}$ can determine which user issued the signature using the following algorithm:

1. For each $i = 1, \dots , n$ run the verification algorithm on $M$, with revocation list $RL = \{\textbf{grt}[i]\}$.
2. Output the index of the first user for which the verification algorithm says invalid. Output fail if the signature verifies properly for all n users.

### q-Strong Diffie-Hellman Assumption (q-SDH)

Let $G_1, G_2$ be cyclic group of prime order $p$, where possibly $G_1 = G_2$. Let $g_1$ be a generator of $G_1$ and $g_2$ a generator of $G_2$. 

The q-SDH problem in $(G_1,G_2)$ is defined as follows: given a $(q+2)$-tuple $(g_1, g_2, g_2^{\gamma} , g_2^{(\gamma^2)} , \dots , g_2^{(\gamma^q)})$ as input, output a pair $(g_1^{1/(\gamma+x)}, x)$, where $x \in \Z_p^*$.  An algorithm $\mathcal{A}$ has advantage $\epsilon$ in solving q-SDH in $(G_1, G_2)$ if 

$$
Pr\Big[A(g_1, g_2, g_2^{\gamma}, \dots , g_2^{(\gamma^q)}) = (g_1^{\frac{1}{\gamma + x}},x)\Big] \ge \epsilon, 
$$

where the probability is over the random choice of generator $g_2 \in G_2$ (with $g_1 \gets \psi(g_2)$), of in $\Z_p$, and of the random bits of $\mathcal{A}$.

## Short VLR group signatures

It is based on q-SDH assumption. 

Consider bilinear groups ($G_1,G_2$) with isomorphism $\psi$ and respective generators $g_1$ and $g_2$ such that $\psi(g_2) = g_1$. 

The scheme employs hash functions $H_0$ and $H$, with respective ranges $G_2^2$ and $\Z_p$.

1. Key Generation: The key generation algorithm takes as input $n$, the number of user keys to generate. It proceeds as follows:
    1. Pick $g_2 \in G_2$ uniformly at random, and set $g_1 \gets \psi(g_2)$. 
    2. Pick $\gamma \xleftarrow{R}{} \Z_p^*$,  and set $w = g_2^{\gamma}$.
    3. Using $\gamma$, generate for each user an SDH tuple $(A_i, x_i)$ by 
        1. selecting $x_i\xleftarrow{R}{} \Z_p^*$ such that $\gamma + x_i \ne 0$
        2. setting $A_i \gets g_1^{1/(\gamma + x_i)}$.
    
    **The group public key** is $gpk = (g_1,  g_2, w)$.  
    
    **Each user’s private key** is her tuple $\textbf{gsk}[i] = (A_i, x_i)$. 
    
    **The revocation token** corresponding to a user’s key $(A_i, x_i)$ is $\textbf{grt}[i] = A_i$.
    
2. Signature Generation: The signing algorithm takes a group public key $gpk = (g_1,  g_2, w)$, a user private key $\textbf{gsk}[i] = (A_i, x_i)$, and a message $M \in \{0, 1\}^*$ as inputs, and proceeds as follows:
    1. Pick a random nonce $r \xleftarrow{R}{} \Z_p$. Obtain generators $(\hat{u}, \hat{v}) \in G_2$ from $H_0$ as 
        
        $$
        (\hat{u}, \hat{v}) \gets H_0(gpk, M, r) \in G_2^2
        $$
        
        and compute their images in $G_1$ 
        
        $$
        u \gets \psi(\hat{u}), ~ v \gets \psi(\hat{v}).
        $$
        
    2. Select an exponent $\alpha \xleftarrow{R}{}\Z_p$ and compute 
        
        $$
        T_1 \gets u^{\alpha}, ~ T_2 \gets A_iv^{\alpha}.
        $$
        
    3. Set $\delta \gets x_i\alpha \in \Z_p.$ 
    4. Pick random blinding values $r_{\alpha}, r_{x}, r_{\delta}$ from $\Z_p$.  
    5. Compute the helper values
        1. $R_1 \gets u^{r_{\alpha}}$
        2. $R_2 \gets e(T_2, g_2)^{r_x} \cdot e(v,w)^{-r_{\alpha}} \cdot e(v, g_2)^{-r_{\delta}}$
        3. $R_3 \gets T_1^{r_x} \cdot u^{-r_{\delta}}$
    6. Compute the challenge $c\gets H(gpk, M, r, T_1, T_2, R_1, R_2, R_3) \in Z_p$ 
    7. Compute 
        1. $s_{\alpha} \gets r_{\alpha} + c\alpha \in \Z_p,$ 
        2. $s_{x} \gets r_{x} + cx_i \in \Z_p,$
        3. $s_{\delta} \gets r_{\delta} + c\delta  \in \Z_p.$
    8. Output the signature $\sigma \gets ( r, T_1, T_2, c, s_{\alpha}, s_x, s_{\delta})$.
3. Verification: The verification algorithm takes a group public key $gpk = (g_1, g_2, w)$, a set $RL$ of revocation tokens (each an element of $G_1)$, a purported signature $\sigma = (r, T_1, T_2, c, s_{\alpha}, s_x, s_{\delta})$, and a message $M \in \{0, 1\}^*$ as inputs, and proceeds in two phases, i.e. ensuring that the signature is valid and ensuring that it was not generated by a revoked user. Verification algorithm returns accepts only if both conditions hold.
    1. Signature check:
        1. Compute $(\hat{u}, \hat{v}) \gets H_0(gpk, M, r) \in G_2^2$
        2. Compute $u \gets \psi(\hat{u}), \text{ and } v \gets \psi(\hat{v}).$
        3. Redrive $R_1, R_2, R_3$:
            
            $\tilde{R_1} \gets u^{s_{\alpha}}/T_1^c$
            
            $\tilde{R}_2 \gets e(T_2, g_2)^{s_x} \cdot e(v,w)^{-s_{\alpha}} \cdot e(v, g_2)^{-s_{\delta}} \cdot \Big(e(T_2, w)/e(g_1,g_2)\Big)^c$
            
            $\tilde{R}_3 \gets T_1^{s_x}\cdot u^{-s_{\delta}}$
            
        4. Check that the challenge $c$ is correct such that
            
             $c \gets H(gpk, M, r, T_1, T_2, \tilde{R}_1, \tilde{R}_2, \tilde{R}_3)$
            
    2. Revocation check: For each element $A \in RL$, check whether $A$ is encoded in $(T_1,T_2)$:
        
        $$
        e(T_2/A, \hat{u}) \stackrel{?}{=} e(T_1, \hat{v})
        $$
        
        If no element of $RL$ is encoded in $(T_1, T_2)$, the signer of $\sigma$ has not been revoked.